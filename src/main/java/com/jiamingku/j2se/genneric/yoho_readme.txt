yoho-dal-erp的分析
1.继承关系体系
基本service开发流程如下
com.yoho.erp.wms.service.check.InStorageCheckDetailService,继承BaseService，

1.1 BaseService 继承 BaseSmartService(基本的增删改查-批量查,批量删等)
1.2 BaseService 继承 BasePageModelService(分页功能)
1.3 BaseService = BaseSmartService(基本的数据库操作)  + BasePageModelService(数据库分页操作)

这个BaseServie开发的目的,减少代码的书写,节省大家的开发工作，开发这个组建，要进行以下功能逻辑的抽象.
目标：表的curd不需要在mappper类中写，但是每个表又不是固定的，对应的实体也不是固定的，但是关键点的逻辑是重复的
     也就说这个利用泛型这个技术点进行的关键
======================0.设计的一个关键点就是
spring 4.0开始提供一个新的特性就是根据泛型进行注入
=====================1.1的设计基本流程.
---实体问题
（表-->实体）操作的都是实体，也就是说逻辑的重复，设计的时候首先要考虑到泛型。
 针对于实体：数据库的设计规范需要有主键，也就是Id，所以任何实体的父类就是IDEntity
 实体抽象的第一步：任何实体必须的继承IDEntity，这个地方有点死，但是也有好处。见下

---核心操作
   1.保存实体
   2.更新实体
   3.删除实体(根据id进行删除)
   4.查询实体(根据id进行查询)
   --剩下额外的扩展就很多种了批量查询,批量保存,但是逻辑重复的点就是都是使用主键+实体

--- 基于上面的,实体问题,核心操作两点，抽象出来一个简单版本就是BaseSmartService的接口就算搞定了

      IDEntity中包含Id类型
    2.实体中包含主键,其实属于一种扩展，针对任何类型的主键，这个其实没啥必要

    3.接口是规范，抽象类是复用，你定义好接口,如果方法全部压到最终端使用者的话那简直就是痛苦
      所以还的来个抽象类BaseSmartServiceImpl，减少最终调用者的工作量，抽象类就的实现对应的逻辑方法
      怎么办这时候类型还都是范型，按照现在主流的开发现在还是在需要借助数据库组建mybatis
      继续来一个mppaer的泛型抽象（com.yoho.core.dal.base.dao.BaseMapper）他使用的便是 主键+实体
      不完美的地方就是这个方法的名字，跟service的名字不一样，service是save，mapper叫insert

    4.妥了，现在基本的代码模型已经出来，现在就是使用者的问题了
        4.1 XXXservice 首先要继承基本的BaseSmartService
            4.1.1 主键的类型告诉我eg:Integer,还有对应的实体类型(实体主键必须，一般数据库表的开始时间+修改时间也是必须的)
            4.1.2 实体继承对应的类就可以了也就是IDEntiy就可以了,这个地方进行了类型上线绑定
        4.2 别忘记了mapper的问题，mapper的问题就是继承basemapper就可以，其实这个继承，只是叫mapper里面的方法
            得已生效，basemapper都是泛型方法，么有具体的类型是不能工作的，继承就是将baseMapper里面的方法继承过来
            mybatis根据接口生成动态代理。

        4.3 到此BaseSmartService的设计使用已经讲完了。回头完成那个 pagemodelservice

--- 分页
    1.对于分页来说一般会有多少条记录
    2.每页显示多少条
    3.总页数
    4.当前页显示的数据
    5.每次按照分页进行查询的时候，数据都是按照从新查询出来的数据
    6.分析现有的抽象逻辑
        6.1分页的数据是通过查询出来的，所以会有一个基本的查询模型(每页条数，当前页数，offset偏移量，这个在mysql分页时候使用）
            就是我们在查询的时候，会带着跟分页相关的信息，当前页等信息，这时候我们继承这个类，其实就相当于查询基类,但是我们在进行查询
            ------------limit #{pageSize} offset #{offset}----------------
            需要使用：分页显示多少条,pageSize, offset=(pageNo - 1) * pageSize,----获取结果集就行了，mysql的分页相对来说比较简单
        6.2 最终要构建出来一个分页的对象，显示给前端，这个分页对象还需要继承BasePageModel，页包含每页显示多少条数据
            给前端显示，就会有总数量，总页数，
            int totalPage = totalCount / getPageSize();
            if (totalPage == 0 || totalCount % getPageSize() != 0) {
            	totalPage++;
            }
            return totalPage;

=====================1.2的设计基本流程.
---吐槽
就拿后台的erp管理系统来说分页是必不可少的一个东西
一般分页的都有一种结构，分页必须的查询总的数量，共多少页，当前页，每页多少条等差不多这样的概念，他这个命名写的不好(BasePageModel--其实应该叫查询对象)
一般企业级应用，在查询的时候会有个查询条件的一个对象封装，如果带分页查询的话会有分页信息(当前页等)，但是他是一个查询对象，我们这里面给他命名了
  继承BasePageModel的这么一个对象，其实目的就是为了获取分页的那几个域信息

---设计分析
为什么会出现这个BasePageModelService，他是将分页的信息与基本的crud信息分开来处理，可能有的业务,db操作没有分页
有的db操作有分页,他分开处理，但是呢，奇怪的事情就是分页模型里面的操作给放在BaseServiceImpl里面，不知道他的代码
模型结构为什么这么写，而且还又一个类com.yoho.core.dal.base.service.impl.BasePageModelServiceImpl，专门的实现了分页功能怪，真他妈的怪
？本来这种结构是应该继承的，但是java是单继承，所以他这个地方只能实现？，直接用一个不久的了么，分开没有用，分开之后，你底层还是用一个baseMapper，
其实分开的效果一点没有用 但是他能用。---java的单继承特性，其实不合并就一个但这分页功能的service就行了。搞的有点复杂。

---分页研究
分页一般我们返回一个对象，其实就是一个报文信息，里面装的是实体的列表信息,一般包含如下信息
1.总数量
2.总页数
3.实体的列表
根据不同的前端组件其实这个显示的信息可能是不他一样的。但是总体必须的包含实体列表，而且是泛型对象，这个也就是我们所说的PageModel
与php合作开发的时候，具体显示多少页信息，这个是前端自己算出来的所以没我们分页模型中不包含这个信息

=====================无论1.1还是1.2接口所定义的信息其实最终他还是依托于BaseMapper这个东西
在往下依赖最终还是依赖于mapper.xml的写法

----------------------------------------------------------------------------

 /**
         *  Quark.class.getTypeParameters() 只能干活去占位符信息，因为泛型擦除.之后没有类型信息.
         */










































