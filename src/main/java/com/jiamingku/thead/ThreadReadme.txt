1.线程构造器六个参数?
2.非公平锁效率高?刚释放锁的线程再次获取同步状态的几率会非常大.
3.lock-Vs-Synchronized?
tryAcquire: 直接通过返回值 true/false 直接返回是否获取锁,[lock]acquire只是将返回失败的入队并且park阻塞当前线程
非阻塞的获取锁,优于synchronized的一个点。或者说是一个区别

4.condition:只能是排他锁才能执行.
5.挂同步队列的时候,双向队列先挂前驱指针,保证在检索的时候从尾巴能遍历全.
6.condition:什么时候将节点从等待队列移走?
6.1.interrupt之后节点是唤醒了但是节点的状态挂到同步队列,但是并没有从等待队列中移除，等到节点再次唤醒的时候,发现后面有节点的时候清理等待队列.
6.2.signal唤醒节点是头节点，这回收头节点移除队列.==在阻塞队列在获取到锁的时候-这时候如果节点后面有节点--就继续唤醒.
6.3.在向等待队列上面挂节点的时候,也可以清理.


1.非公平锁：
为什么会出现线程连续获取锁的情况呢？ 刚释放锁的线程再次获取同步状态的几率会非常大，



1.非公平锁：
为什么会出现线程连续获取锁的情况呢？ 刚释放锁的线程再次获取同步状态的几率会非常大，

2.非公平效果要优于公平，原因就是公平导致上下文切换比较多,所以导致性能不如非公平好。

会造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。



锁降级：把持住写锁的时候获取读锁，在释放写锁的过程叫锁降级（获取写锁在释放在获取读。那不叫锁降级

=============
同步队列:
节点变动有2个地方可以,取消时候,或者是等待节点拿到锁之后更换头.(setHeadAndPropagate)